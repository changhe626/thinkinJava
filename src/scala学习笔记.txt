注意的是 Scala 不支持 ++i 和 i++ 运算符，因此需要使用 i += 1 来加一
Scala 访问数组的语法是使用 () 而非 [] 。

Scala 使用方括号来指明数据类型参数，而非尖括号




 Trait 的概念类似于Java中的 Interface，所不同的Scala中的 Trait 可以有方法的实现

 Mutable （可变）和 Immutable （不可变）

 一个简单的原则，如果代码中含有 var 类型的变量，这段代码就是传统的指令式编程，如果代码只有 val 变量，这段代码就很有可能是函数式代码，因此学会函数式编程关键是不使用 vars 来编写代码。

 尽量少用 vars 的好处，代码更简洁和明了，从而也可以减少错误的发生。因此 Scala 编程的一个基本原则上，能不用 vars，尽量不用 vars，能不用 mutable 变量，尽量不用 mutable 变量，能避免函数的副作用，尽量不产生副作用。




 慕课网:(辰方)
1.1
函数式思想(重点)
面向对象/面向函数式的两种方式


1.2
函数式编程的概念:

把计算当做函数的计算过程,避免状态.

纯函数:函数的纯粹性,没有副作用(状态的变化)
数据都是不可变的,全部是final类型的

引用透明性,
相同的输入,总是得到相同的输出,反例: java的append方法

不变性
为了获取引用透明性,任何值都不能变化

函数是一等功能
一切都是计算,函数式编程中只有表达式,变量,函数都是表达式
高阶函数
闭包


表达式求值:严格求值,非严格求值
惰性求值


递归函数
递归实现循环
尾递归


函数式编程的优点:
生产效率高
易于推理
并行编程,多核计算,云计算


2.1搭环境
安装
SBT(Simple Build Tool)
cmd 中 sbt命令就行了
REPL(read Evaluate Print loop)交互式编程,编程得到结果
输入scala就进入环境了

sbt console  同样进入环境

IDE:
ScalaIDE(√)
IDEA


用文本的方式:
后缀.scala  源文件
scalac  X.scala 编译(要到scala安装目录下)
scala X 运行


3.1基础语法之变量
变量:
val immutable variable常量(不可修改)
var mutable   variable变量
lazy val 惰性求值常量
可以不显示指定变量的类型,因为scala会自动进行类型推到


val  x=10
val y:Int=20
x+y
可以直接引用res0

lazy val z=x-y;
不会马上求值,当第一次用到z的时候就会进行计算求值了

什么时候用lazy val? 定义的变量后面可能不会被用到,可以定义为lazy val.


3.2数据类型

Any(所有scala类父类)
AnyVal(值类型)           AnyRef(所有引用的父类)
Numeric type(数值)     All java/scala.* ref types
Boolean
Char
Unit(空类型,类似void)


Null是所有引用类型的最后一个子类
Nothing是所有scala的最后一个子类


val a:Byte=10
val b:Short=20
val c:Int =40
val d:Long=50

val e:Float=50
val f:Double=60.32

val x:Long=b  低向高转换
高向低转换会报错

boolean

true/false
val m=true
val n=false

val q='X'

val u:Unit=()
val p=()

Null和java的相同
用的少,用的Nothing

抛出异常了,返回值是Nothing

String就是java的
新增字符串插值(interpolation)
val myname="ke"
s"my name is ${myname}"
小写的s进行标记,就得到一个新的字符串了,进行了替换


3.3函数与代码块

代码块Block也是一个表达式,其最终的求得的值是最后一个表达式的值

{exp1;exp2}

{
exp1
exp2
}

函数的定义:
def functionName(param:ParamType):ReturnType={
	//function body:expression
}

object funcExample{
	hello("sss")

	//制定返回类型
	def hello(name:String):String={
		s"hello world,${name}"
	}

	//不定义,自己推断返回类型
	def hello(name:String)={
		s"hello world,${name}"
	}

	def add(x:Int,y:Int)=x+y

	//只有一个代码块的{} 可以省略不写的

}


3.4 if和for

if表达式

val a=1
if(a!=1) "not one"
//> res0:Any()
因为表达式不成立,所以返回就是空,就是Unit,只是它的表现形式

for comprehension
循环推导

val l=List("aa","bbbb","ccbb");

for(
	s<-l //generator  循环遍历
)println(s)


for{
	s<-l
	if(s.length>3) 不满足就直接下一次循环,不打印了
}println(s)


val result_for=for{
	s<-l;
	s1=s.toUpperCase()  //variable binding
	if(s1!="")
}yield(s1)   //generator new Collention yield导出


3.5 try和match表达式

try语义和java 中一样,不过在scala中是一个表达式,会返回一个值


val result_try=try{
Integer.parseInt("da")
}catch{
case_=>0      //_是通配符,同时返回0
}finally{
println("always be printed")
}

match表达式
和switch类似

exp match{ //主要用在pattern match中
	case p1=>val1
	case p2=>val2
	...
	case_=valn
}


val code=1
var result_match=code match{
	case 1=>"one"
	case 2=>"two"
	case _=>"three"   //类似default
}



4.1求值策略

scala有两种
 call by value 对函数实参求值,且仅求值一次
 call by Name  函数实参每次在函数体内被用到时都会求值

scala通常使用call by value
如果函数形参类型以=>开头,那么会使用call by name
def foo(x:Int)=x    //call by value
def foo(x:=>Int)=x  //call by name








