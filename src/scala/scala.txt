
代码块,都有返回结果,哪怕是空

for(i <- 1 to 10) println(i)

1 to 10

for(i <- 0 until 10) println(i)
打印0-9

0 until 10


val str="hello123"
for( c <-str) println(c) 依次遍历字符串

str.charAt(0)  对应的字符
str.charAt(100)  报出异常了

字符串的遍历
for(c<- 0 until str.length) println(str.charAt(i))

定义数组
val arr=Array(1,2,3,5,7,4)
取值
for(i<- arr) println(i)

取值
arr(0)
也会造成越界

for(i<- 0 until arr.length) println(arr(i))

双层for循环
for(i<- 1 to 3;j<- 1 to 3 if i!=j )
print((10*i+j)+"")
println()


for推导式:如果for循环的循环体以yield开始,则该循环会构建出一个集合
//每次迭代生成集合中的一个值
val v=for(i<- 1 to 10) yield i*10
println(v)


val arr=Array(1,3,5,3,7)
for(i<- arr) yield i*10
返回的类型和原类型相同


arr.map(_ * 10)
arr.map(x=>x*10)

取出其中偶数,*200
for(i<-arr if i%2==0) yield i*200

arr.filter(m => m%2==0).map(n=>n*200)



方法的定义
def say():Unit={println("hi")  } 
def say(){println("hi") }
def say()={println("hi")}



如何定义函数?
特征:=>
=> 左边是参数列表,右边是函数体,可以用{}
(x:Int,y:Int)=>x+y

val f1=(x:Int,y:Int)=>x+y
val f2:(Int,Int)=>Int={(x,y)=>x+y}  不容易看,详细

用变量f1来引用定义的函数.
f1(3,5)
函数可以作为参数传入到方法里.

val f3:Int=>Double={ x=>x.toDouble}

val f4=(x:Int)=>x.toDouble 

无参,只打印5,返回Unit
val f5=() =>println(5)
调用f5()


输入两个Int,返回Double类型的...new 接口,实现方法
val f6=new Function2[Int,Int,Double]{
	def apply(x:Int,y:Int)={x+y}
}

匿名函数(用的最多的是直接放到方法里):


























val p= (x:Int)=>x%2==0

arr.filter(p)

arr.filter((x)=>x%2==0)

arr.filter(x=>x%2==0)

arr.filter(_%2==0)


map的实现方式?我们自己怎么实现一个这样的方法,接受函数作为参数,返回处理完的结果.

var arr=Array(1,2,3,4,5,6)
val r=arr.map(_*10)

定义一个Transform类,有一个叫map的方法,接收一个数组,返回一个新的数组 ArrayList[Integer] map(List[Integer] list,?)
方法转换成函数:
val arr=Array(1,2,3,4,5,6,7)

arr.map(x=>x*x)
定义方法:
def m1(x:Int):Int=x*x
m1(5)

arr.map(m1)   行吗?   可以的







scala集合

数组:
val arr=Array[Int](1,3,5,7,4)

val arr2=new Array[Int](8)   8个0 ,8是长度,Int的默认值是0

val arr3=new Array[String](6)   6个null

val arr4=Array("a","c","d")

print(arr.toBuffer)  打印

val修饰的数组,能够改变其中的值.引用不能改,但是数组中的内容可以改变
arr4(1)="hel"  修改

Array长度也不可变

变长的集合,可变集合
import scala.collection.mutable._
val ab=new ArrayBuffer[Int]()   长度为0

ab+=1  追加进去   ab.append(8)   可以append多个 (9,9,9,9)

ab+=3

ab-=3  减去,是从前往后减去,从前往后找       

ab-=4  不存在就不会被删除了

ab+=(1,2,3)

val ab2=ArrayBuffer(5,4,3,2,1)

将ab2的元素加到ab里去 ab++=ab2

ab++=Array(6,7)     
ab++=ArrayBuffer(8,7)  也可以是ab++ArrayBuffer(8,7)
  
ab.insert(0,0,-1)  这些元素追击到前面去了
第一个参数是角标,后面是要追加的元素

ab.insert(10,2)  超过范围会报数组下标越界异常

ab2.remove(1,4)  从下标1开始移除4个,只有ArrayBuuffer有这个方法的

ab2.remove(10,1)   超过范围会报数组下标越界异常


集合2
定长/变长
不可变/可变集合
immutable/mutable

val im=new  scala.collection.immutable.HashMap[String,Int]()

val im2=scala.collection.immutable.HashMap[String,Int]("1"->1,"2"->2,"3"->3)

im2("1")=10   不可变集合,他的内容都不可改变!!!


可变
val  map=new scala.collection.mutable.HashMap[String,Int]()

map.put("1",1)

map+=("2"->2)

map+="2"->2

map-="1"   删除一个key-value


List
val ls=List(1,2,3,4)

ls(0)=44  不可变的list改变值失败

可变的
val  lb=ListBuffer(1,3,5,7)

追加多个  lb+=(5,6,8)
lb++=ls


Set

val set=Set(1,3,4,5,5,6)

set+=7   无序哦

还有不可变的Set

set-=2

移除不包含的元素也不报错了











  




