
EXPLAIN执行计划中有一列 key_len 用于表示本次查询中，所选择的索引长度有多少字节，通常我们可借此判断联合索引有多少列被选择了。

在这里 key_len 大小的计算规则是：

一般地，key_len 等于索引列类型字节长度，例如int类型为4 bytes，bigint为8 bytes；
如果是字符串类型，还需要同时考虑字符集因素，例如：CHAR(30) UTF8则key_len至少是90 bytes；
若该列类型定义时允许NULL，其key_len还需要再加 1 bytes；
若该列类型为变长类型，例如 VARCHAR（TEXT\BLOB不允许整列创建索引，如果创建部分索引也被视为动态列类型），其key_len还需要再加 2 bytes;



那么如果查询中存在between 和like，MySQL是如何进行处理的呢？

Between

where c1 between  'a' and 'b' 等价于 where c1>='a' and c1 <='b'，所以进行相应的替换，然后带入上层模型，确定上下边界即可。

Like

首先需要确认的是%不能是最在最左侧，where c1 like '%a' 这样的查询是无法利用索引的，因为索引的匹配需要符合最左前缀原则。

where c1 like 'a%'  其实等价于 where c1>='a' and c1<'b' 大家可以仔细思考下。

在数据库中，如果无法利用索引完成排序，随着过滤数据的数据量的上升，排序的成本会越来越大，即使是采用了limit，
但是数据库是会选择将结果集进行全部排序，再取排序后的limit 记录，而且MySQL 针对可以用索引完成排序的limit 有优化，更能减少成本。


group by的效率和distinct与order by的效率比较哪个更好 ？
没有区别，因为没有 limit 关键字，所以两个都是进行全局扫描 。


主键索引，简称主键，原文是PRIMARY KEY，由一个或多个列组成，用于唯一性标识数据表中的某一条记录。
一个表可以没有主键，但最多只能有一个主键，并且主键值不能包含NULL。
在MySQL中，InnoDB数据表的主键设计我们通常遵循几个原则：
采用一个没有业务用途的自增属性列作为主键；
主键字段值总是不更新，只有新增或者删除两种操作；
不选择会动态更新的类型，比如当前时间戳等。
这么做的好处有几点：
新增数据时，由于主键值是顺序增长的，innodb page发生分裂的概率降低了；可以参考以往的分享“[MySQL FAQ]系列 — 为什么InnoDB表要建议用自增列做主键”；
业务数据有变更时，不修改主键值，物理存储位置发生变化的概率降低了，innodb page中产生碎片的概率也降低了。





















